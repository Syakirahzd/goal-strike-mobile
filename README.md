1. Jelaskan mengapa kita perlu membuat model Dart saat mengambil/mengirim data JSON? Apa konsekuensinya jika langsung memetakan Map<String, dynamic> tanpa model (terkait validasi tipe, null-safety, maintainability)?

Dalam pengambilan ataupun pengiriman data JSON, pembuatan model Dart sangat penting karena Dart merupakan bahasa yang strongly typed, sehingga setiap data perlu memiliki struktur dan tipe yang jelas. Dengan menggunakan model, proses konversi JSON menjadi objek menjadi lebih aman, terorganisir, dan mudah dikelola. Tanpa model dan langsung menggunakan Map<String, dynamic>, aplikasi akan lebih rentan terhadap berbagai masalah seperti kesalahan tipe data, nilai null yang tidak terduga, serta potensi typo pada key JSON yang dapat menyebabkan error saat runtime. Selain itu, kode juga akan menjadi lebih sulit dipelihara dan tidak terstruktur. Pada implementasi saya, model seperti ProductsEntry memastikan bahwa setiap data dari Django memiliki struktur yang benar sehingga aman digunakan di seluruh bagian aplikasi.


2. Apa fungsi package http dan CookieRequest dalam tugas ini? Jelaskan perbedaan peran http vs CookieRequest.
   
Package http berfungsi sebagai alat komunikasi dasar antara Flutter dan server melalui protokol HTTP, namun tidak menyimpan cookie atau mengelola autentikasi. Di sisi lain, CookieRequest dari package pbp_django_auth memiliki peran khusus untuk menangani komunikasi dengan backend Django yang menggunakan session-based authentication. CookieRequest secara otomatis menyimpan dan mengirimkan cookie, termasuk session ID dan CSRF token, sehingga user yang telah login akan tetap dianggap login di setiap request. Karena aplikasi ini membutuhkan autentikasi untuk mengakses data tertentu, maka CookieRequest menjadi solusi yang lebih tepat dibandingkan http.


3. Jelaskan mengapa instance CookieRequest perlu untuk dibagikan ke semua komponen di aplikasi Flutter. 

Instance CookieRequest wajib dibagikan ke seluruh komponen agar status autentikasi tetap konsisten di semua halaman. Ketika user melakukan login, session dan cookie disimpan dalam instance tersebut. Jika setiap halaman memiliki instance sendiri, maka status login akan hilang sehingga Django akan selalu menganggap user sebagai anonymous. Dengan menggunakan Provider untuk membagikan instance yang sama ke seluruh widget tree, aplikasi dapat mempertahankan autentikasi yang sama, menampilkan data khusus user, dan menjaga alur login agar tetap berjalan dengan benar. Pada kode saya, hal ini terlihat saat halaman produk mengambil request dari context.watch<CookieRequest>().


4. Jelaskan konfigurasi konektivitas yang diperlukan agar Flutter dapat berkomunikasi dengan Django. Mengapa kita perlu menambahkan 10.0.2.2 pada ALLOWED_HOSTS, mengaktifkan CORS dan pengaturan SameSite/cookie, dan menambahkan izin akses internet di Android? Apa yang akan terjadi jika konfigurasi tersebut tidak dilakukan dengan benar?

Agar Flutter dapat berkomunikasi dengan Django, diperlukan konfigurasi tertentu pada kedua sisi. Pertama, alamat 10.0.2.2 harus ditambahkan ke ALLOWED_HOSTS di Django karena Android emulator tidak dapat mengakses localhost secara langsung; alamat itu adalah jembatan khusus ke komputer host. Selain itu, Django harus mengaktifkan CORS agar mengizinkan permintaan dari aplikasi Flutter, serta mengatur cookie dengan SameSite=None dan mengizinkan pengiriman cookie lintas domain. Di sisi Android, permission internet juga harus ditambahkan pada AndroidManifest.xml, karena tanpa izin ini aplikasi Flutter tidak dapat melakukan request jaringan sama sekali. Jika salah satu konfigurasi ini tidak dilakukan dengan benar, maka permintaan dari Flutter akan ditolak, cookie tidak akan terkirim, data tidak dapat diambil, dan proses login akan gagal.


5. Jelaskan mekanisme pengiriman data mulai dari input hingga dapat ditampilkan pada Flutter.

Alur pengiriman data dimulai ketika pengguna mengisi form pada Flutter. Data tersebut kemudian dikirim ke Django dalam format JSON melalui metode post atau get milik CookieRequest. Django menerima data tersebut, memvalidasinya, dan menyimpannya ke dalam database. Setelah data berhasil disimpan, Flutter akan melakukan request untuk mengambil data terbaru menggunakan endpoint JSON dari Django. Data yang diterima berupa list map JSON, yang kemudian diubah menjadi objek model seperti ProductsEntry melalui factory fromJson(). Setelah diproses, data ditampilkan ke pengguna melalui widget seperti ListView.builder. Pada kode saya, mekanisme ini terlihat jelas dalam fungsi fetchProduct() dan FutureBuilder.


6. Jelaskan mekanisme autentikasi dari login, register, hingga logout. Mulai dari input data akun pada Flutter ke Django hingga selesainya proses autentikasi oleh Django dan tampilnya menu pada Flutter.

Proses autentikasi dimulai dari Flutter ketika pengguna mengisi form login atau register. Data ini dikirim ke Django melalui CookieRequest. Pada register, Django akan membuat akun baru dan mengembalikan respon yang menandakan keberhasilan registrasi. Pada login, Django memvalidasi kombinasi username dan password. Jika sesuai, Django membuat session baru dan mengirimkan cookie session kepada Flutter. CookieRequest menyimpan cookie ini sehingga Flutter dapat mengakses endpoint yang membutuhkan autentikasi. Logout dilakukan dengan mengirim request ke endpoint Django yang menghapus session user. Setelah logout berhasil, cookie pada Flutter dibersihkan sehingga user kembali dianggap tidak login. Alur ini memastikan bahwa pengguna hanya dapat mengakses data tertentu setelah autentikasi berhasil.

7. Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step! (bukan hanya sekadar mengikuti tutorial).

Saya mengimplementasikan checklist dengan mengikuti alur kerja yang sistematis. Pertama, saya membuat model Dart berdasarkan struktur JSON dari Django untuk memastikan data dapat dipetakan dengan aman. Setelah itu, saya mengonfigurasi proyek Flutter agar menggunakan Provider untuk menyediakan satu instance CookieRequest ke seluruh aplikasi. Kemudian, saya membuat fungsi fetch dan UI untuk menampilkan list produk menggunakan FutureBuilder. Di Django, saya menambahkan endpoint JSON, mengaktifkan CORS, dan menambahkan 10.0.2.2 ke ALLOWED_HOSTS. Saya juga mengatur cookie dan CSRF agar kompatibel dengan Flutter. Untuk autentikasi, saya menghubungkan form login, register, dan logout di Flutter dengan endpoint Django menggunakan CookieRequest. Akhirnya, saya memastikan semua fitur berjalan dengan melakukan testing pada emulator dan memperbaiki setiap error yang muncul sampai seluruh alur data dan autentikasi berjalan lancar.
